---
layout: post
title:  "자바 - 자바의 비교(==, equals, hashCode)"
date:   2019-03-24
description: 자바의 비교에 대해서 정리한 내용입니다.
tags: [java, 비교, 동일성, 동등성, equals, hashCode, ==]
category: java
---


자바의 동일성, 동등성, key에대한 중복 등 조금은 복잡한 비교체계를 가지고 있습니다. equals함수를 오버라이딩 할 때 왜 hash함수를 오버라이드하는지에 대한 질문을 받았었는데요. 제대로 명확하게 대답하지 못했습니다. 그래서 오늘 확실히 정리를 하고자합니다.

<br/>

### 동일성, 동등성

<br/>

먼저 자바에서 ==연산과 .equals에 대해서 설명이 필요합니다.

<br/>

**동일성**

<br/>

동일성은 각각의**존재가 같은 경우**를 말합니다. 예를 들어 어떤 한사람이 이름을 별명(노력이, 성장이) 노력이든 성장이든 결국은 하나의 존재를 말합니다. 

사전의 정의는 이렇습니다. 

<br/>

> 각각 다른 것이 아니라 하나임 

<br/>

<br/>

**동등성**

<br/>

동등성이란 각각의 "존재의 등급이 같은 경우"를 말합니다. 아메리카노 2개를 시켰지만 두개다 결국은 아메리카노입니다.

<br/>

사전의 정의는 이렇습니다. 

> 등급이나 정도가 같음

<br/>

여기서 얻을 수 있는 것은 일단 동일하다는 것은 동등하다는 것입니다. 그리고 동등하다고 꼭 동일하다고는 할 수 없습니다.

 <br/>

![image-20190324143401799](/Users/veo/Library/Application Support/typora-user-images/image-20190324143401799.png)



<br/>

**==, equals**

<br/>

자바에서는 이러한 동일성, 동등성을 비교하기위해서 ==연산과, equals 메서드가 있습니다. 하지만 ==과 equals는 제공하는 역할이 너무 비슷한데요 이를 확실히 구분하고 가도록하겠습니다. 

- ==연산

  - primitive type

    primitive type에 대해서는 값이 같은지를 검사합니다.

  - reference type

    reference type에 대해서는 주소가 같은지 검사합니다.

<br/>

- equals 연산

  - reference type

    오버라이드 하지 않았을 경우 default는 reference type에 대해서 주소가 같은지 검사합니다.

<br/>

비슷한 이유를 아시겠나요? 결국 equals메서드의 default는 ==연산과 다를바 없이 reference type에 대해서 주소가 같은지를 검사합니다. 

<br/>

어찌보면 당연한 얘기입니다. 객체들의 동등성을 따지기에는 어떤식으로 객체들의 동등성을 따질지에 대한 기준이 없고 클래스마다 다릅니다.

<br/>

즉 클래스를 만들 때에만 결정할 수 있습니다. Object 클래스에서는 결정할 수가 없는 사항입니다. 그래서 확실한 것!! 즉 동일하다는 것은 동등하다는 것을 확실히 보장할 수 있기때문에 객체들의 주소값을 비교하여 똑같으면 동등하다고 default로 쓰이는 것입니다. 

<br/>

객체가 가지고 있는 정보가 같을 때 동등하다고 말하고 싶다면?

<br/>

그때서야 class를 만들 때 equals함수를 오버라이드해서 객체들의 정보가 같은 때 true를 리턴하도록 하면됩니다.

<br/>

이제 조금 이해가시나요?? 이제 ==연산과 equals연산에 대해서는 확실히 정리가 된듯합니다. 

<br/>

<br/>

### equals메서드와 hashCode메서드의 관계

<br/>

그렇다면 한 단계 더 들어가서 equals메서드와 hashCode의 관계에 대해서 다뤄보도록 하겠습니다. 

<br/>

아까 말했듯이 equals메서드는 동등성을 비교한다고 말했습니다. 그럼 본론에 앞서 HashMap이나 HashSet, HashTable에 대해서 살펴보도록 하겠습니다. 

<br/>

컬렉션 프레임워크 HashMap, HashSet, HashTable은 중복을 허락하지 않는 컬렉션들인데요. 이 중복을 어떤 프로세스에 의해서 찾아내는지는 다음과 같습니다.

<br/>

![image-20190324152338778](/Users/veo/Library/Application Support/typora-user-images/image-20190324152338778.png)

<br/>

먼저 hashCode()를 통해서 값이 같은지 확인하고요 같다면 equals로 비교를 해봅니다. **정말 좋은 hash방식이라도 다른 값일 때 똑같은 hash값이 나올 수 있기 때문입니다.** 그래서 꼭 같은게 있다면 equals로 정말 동등한지 검사를 해줘야합니다. 

<br/>

하지만 hash함수를 통해서 equals연산을 할 대상은 어마어마하게 줄어듭니다. 즉 성능을 위해서 앞에 hashCode()를 통해 비교가 먼저 들어갑니다. 

<br/>

앞에서 중복을 찾아내는 프로세스는 알았습니다. 그렇다면 중복을 판단하는 기준은 무엇일까요? 보통 콜렉션들은 데이터들을 보관하기 위한 API입니다. 그리고 데이터들은 값이죠. 맞습니다. 중복을 처리할 때는 값들을 비교해줘야 합니다. 

<br/>

물론 객체가 똑같아야 중복이야라고 생각할 수 있고 그렇게 해야하는 상황이 있을겁니다. 그때는 그냥 equals나 hashCode를 오버라이드 해주지 않으면됩니다. 즉 이말은 default로 쓴다는 것이고 default는 객체가 동일할 때 동등하다고 판단하니까요. 

<br/>

하지만 객체들의 정보가 같을 때를 중복된다고 말하고 싶을때는 equals메서드를 오버라이드 하게됩니다. 그럼 동등성에 대한 새로운 기준이 생기는 거죠. 바로 가지는 정보가 같다면이라는 기준이요.

<br/>

그럼 이걸로 끝일까요?? 아니요 아까 중복을 찾아내는 프로세스에서 봤듯이 먼저 검사하는 것은 hashCode메서드 입니다. hashCode가 달라버리면 아무리 equals메서드에 대한 리턴값이 true이더라도 서로 중복이 아니라고 판단해버립니다. 

<br/>

또한 hashCode의 default는 객체의 메모리번지를 이용해서 해시코드를 만듭니다. 즉 객체가 동일할 때 똑같은 해시코드를 리턴하는 것을 보장하는 군요. 

<br/>

그렇다면 우리의 목표는 객체의 정보가 같을 때 똑같은 해시코드를 리턴하는 것을 보장해야한다가 되겠군요. 

<br/>

그렇지 않고는 컬렉션들에 대한 의도치 않는 상황(객체들이 동등성은 true인데 서로 다른것으로 판단하는 상황)이 생길 수 있다는 거군요!! 

<br/>

**즉 equals메서드를 오버라이드 했다면 hashCode도 오버라이드해줘야 컬렉션들에 대한 의도치 않는 상황을 방지할 수 있겠군요!! **

<br/>

맞습니다. 그래서 자바에서도 이를 인지하고 규약을 정하고 있습니다. 대략 내용은 다음과 같습니다. 

<br/>

>  equals(Object)메소드가 true이면 두 객체의 hashCode값은 같아야 한다.
>
> <br/>
>
> equals(Object)메소드가 false이면 두 객체의 hashCode가 꼭 다를 필요는 없다. 
>
> <br/>
>
> 하지만 서로 다른 hashCode값이 나오면 해시 테이블(hash table)의 성능이 향상될 수 있다는 것은 이해하고 있어야 한다.

<br/>

<br/>

### 결론

<br/>

자바의 비교에 대해서 내용을 정리해보았습니다.

요약을 하자면 다음과 같습니다.

<br/>

두 개의 객체를 비교할 때 동일성과 동등성이 있습니다.

동일성은 둘은 하나다(어떤 기준에 의해서가 아니라 진짜로 물리적으로)의미하고 동등성은 똑같은 등급(어떤 기준에 의한 같음)을 의미하며 두 개의 객체 비교에 대한 기준이됩니다.

equals를 오버라이드 하지 않는 상황에서는 동등성과 동일성은 똑같은 개념입니다.

하지만 개발자마다 객체가 똑같다고 판단하는 기준은 달라질 수 있습니다. 

이럴 때 equals를 오버라이드해서 그 기준을 설정합니다. 

이때 hash컬렉션들은 성능때문에 hash를 통해서 먼저 두개의 객체를 비교하기 때문에 hashCode도 그 기준을 맞춰줘야 합니다. 

여기서 아무리 좋은 hash알고리즘이더라도 서로 다른 값에 대해서 hash값이 같을 수 있기 때문에 줄어든 범위에 대해서 equals를 해줘야 합니다.

<br/>

<br/>

### 참고자료 

https://jeong-pro.tistory.com/172

https://minwan1.github.io/2018/07/03/2018-07-03-equals,hashcode/

http://blog.naver.com/PostView.nhn?blogId=travelmaps&logNo=220931531769&redirect=Dlog&widgetTypeCall=true