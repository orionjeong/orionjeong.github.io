---
layout: post
title:  DB 기초 시리즈5 - 동시성제어, DB회복관리
date:   2019-03-03
description: DB 기초 시리즈5로 DB의 동시성제어 방식과 회복에 대해서 정리해보았습니다. 
tags: [DB, Databases, 기초, DBMS, transaction, 트랜잭션]
category: [DB, 면접]
---


이번 시간에는 동시성 제어에 대해서 개념을 정리해보도록 하겠습니다. 

저는 "IT CookBook, 오라클로 배우는 데이터베이스 개론과 실습 - 한빛아카데미" 이 책을 통해서 정리를 했는데요, 모두 한 번쯤 읽어봤으면 합니다. 꼭 사서 읽어보세요~~ 추천드립니다.

<br/>

두개의 트랜잭션이 동시에 일어나게 된다면 일관성이 깨질 수 있습니다. 이를 위해서 고립성을 만족시켜줘야 하는데요. 그래서 활용되는 기술이 동시성 제어입니다. 

<br/>

<br/>

**동시성 제어의 개념**

<br/>

동시성제어는 **트랜잭션이 동시에 수행될 때, 일관성을 해치지 않도록 트랜잭션의 데이터 접근을 제어하는 DBMS의 기능을 동시성 제어라고 합니다.**

<br/>

<br/>

**동시성 제어의 종류**

<br/>

1. 락(lock)
2. 트랜잭션 고립 수준

<br/>

한개의 데이터에 여러 트랜잭션이 동시 접근했을 때 생길 수 있는 상황을 정리한 표입니다. 

<br/>

| 상황   | 트랜잭션 1 | 트랜잭션 2 | 발생 문제                                    | 동시 접근           |
| ------ | ---------- | ---------- | -------------------------------------------- | ------------------- |
| 상황 1 | 읽기       | 읽기       | 없음(읽기만 하면 아무 문제가 없음)           | 허용                |
| 상황 2 | 읽기       | 쓰기       | 오손 읽기, 반복불가능 읽기, 유령 데이터 읽기 | 허용 혹은 불가 선택 |
| 상황 3 | 쓰기       | 쓰기       | 갱신손실(절대 허용하면 안됨)                 | 허용불가 (Lock사용) |

<br/>

상황 1은 서로 읽기만 하기 때문에 아무 문제가 발생하지 않습니다. 그러나 상황 2와 상황 3부터 문제가 발생합니다. 그중에서도 상황 3은 아주 심각한 문제가 발생할 수 있는데요, 상황 3에서 발생할 수 있는 문제를 갱신손실이라고 합니다. 

<br/>

갱신손실은 서로 하나의 데이터를 변경했을 때 마지막 변경이 그 전의 변경을 덮어버리면서 갱신된 값을 손실하게 되는 것을 말합니다.  

<br/>

얘를 들어 A라는 트랜잭션과 B라는 트랜잭션이 동시에 실행됩니다. A는 돈을 인출하는 행위였고, B는 돈을 입금하는 행위였습니다. 먼저 데이터베이스에 저장된 값은 주기억장치의 버퍼에 저장되게됩니다. 그래서 두개의 트랜잭션 모두 1000원이라는 값을 버퍼에 가지고 있습니다. A는 -100원을 인출합니다. 그래서 버퍼에 남은 잔액은 900원이 됩니다. B는 +100원을 입금합니다. 버퍼에 있던 값 1000 + 100원을 하게 되면 1100을 가지게됩니다. 이 데이터를 적용하게 되면 원래는 900원 이었던 잔액이 1100원으로 덮어쓰이는 현상이 발생합니다. 절대 발생해서는 안되는 일관성이 깨지는 현상이기 때문에 이를 통제할 만한 기술이 있어야합니다. 

<br/>

<br/>

### 락(lock) 

<br/>

갱신손실에 대한 해결책으로 락에 대해서 알아보도록 하겠습니다.

<br/>

**락(lock)의 개념**

<br/>

위의 갱신 손실과 같은 문제를 해결하기 위해서 쓰이는 데이터베이스의 기술이 있습니다. 이를 락이라고 하는데요. 락의 정의는 다음과 같습니다. 

> 트랜잭션이 데이터를 읽거나 수정할 때 데이터에 표시하는 잠금 장치입니다.

<br/>

자신이 사용할 데이터에 락을 사용하면 다른 트랜잭션은 그 락이 풀릴 때까지 기다려야 합니다. 락을 활용하면 데이터에 대한 갱신을 순차적으로 진행할 수 있기 때문에 갱신손실 문제를 해결할 수 있습니다. 

<br/>

<br/>

**락의 유형**

<br/>

락은 다른 트랜잭션을 대기 상태로 만드는 일을 하기 때문에 사용자의 응답시간에 영향을 줍니다. 그래서 가능하면 최소화 해야합니다. 수강신청을 할 때 동시 접속자 수가 많으면 응답시간이 느려져 불편함을 느끼는 이유가 이런데에 있습니다.

<br/>

트랜잭션이 다루는 데이터에는 세가지 종류가 있는데요, 읽기만 하는 데이터, 읽고 쓰는 데이터, 쓰기만 하는 데이터가 있습니다.

여기서 읽기만 하는 데이터는 변경이 없기 때문에 크게 문제가 없습니다. 그래서 락의 유형을 두가지로 나눕니다. 트랜잭션이 **읽기를 할 때 사용하는 락을 공유락 이라고 합니다**. **읽고 쓰기를 할 때 사용하는 락을 배타락이라고 합니다.** 

<br/>

그리고 이  두가지의 락은 다음과 같은 호환을 가집니다. 

| 요청      \      상태 | LS 상태 | LX 상태 |
| --------------------- | ------- | ------- |
| LS(공유락) 요청       | 허용    | 대기    |
| LX(배타락) 요청       | 대기    | 대기    |

데이터를 읽고 있을 때는 읽기 요청은 가능하지만 쓰기 요청은 안됩니다. 쓰고 있을 때는 당연히 어떤 요청이 들어와도 안됩니다.

 <br/>

<br/>

**2단계 락킹**

<br/>

이처럼 락을 이용하면 갱신손실 문제를 해결할 수 있습니다. 하지만 락을 걸고 해제하는 시점에 제한을 두 지 않으면 두 개의 트랜잭션이 동시에 실행 될 때 데이터의 일관성이 깨질 수 있는데요, 즉 데이터에 락을 걸었다 풀고 다시 거는 중간 과정에 락의 해지 상태가 생기면 다른 트랜잭션이 득달같이 달려들 수 있기 때문에 이런것들을 방지하기 위해서 2단계 락킹을 사용합니다 . 이 기법은 트랜잭션이 락을 걸고 해제하는 시점을 다음과 같이 2단계로 나누어 진행합니다.

<br/>

1. 확장 단계(Growing phase, Expanding phase) - 트랜잭션이 필요한 락을 획득하는 단계로, 이 단계에서는 이미 획득한 락을 해제하지 않습니다. 

<br/>

1. 수축 단계(Shrinking phase) - 트랜잭션이 락을 해제하는 단계로, 이 단계에서는 새로운 락을 획득하지 않습니다.

<br/>

이 두가지 단계에서의 내용의 핵심은 데이터에 대한 동작 중간에 락을 끊지 말라는 것이다. 락을 새로 걸려고 한다면 기존의 락을 풀지 말고 계속 유지해야 새로 거는 동안의 잠깐 동안 다른 트랙잭션의 영향을 막을 수 있습니다. 락의 확장단계에서는 **락을 풀지 말고** , 락의 축소 단계에서 **락을 걸지 말라**을 걸지 말자.를 기억하시면 됩니다. 

<br/><br/>

**데드락**

<br/>

락킹을 2단계 락킹 기법을 톹해서 사용하면 이제 데이터의 일관성을 유지할 수 있습니다. 그렇지만 두 개 이상의 트랜잭션이 각각 자신의 데이터에 대해서 락을 획득하고 상대방 데이터에 대하여 락을 요청하면 무한 대기 상태에 빠질 수 있는데 이를 **데드락 혹은 교착상태**라고 합니다. 

<br/>

즉 서로 락이 걸린상태에서 서로의 데이터가 풀리기를 기다리고 있는 현상을 말합니다. 데이터베이스는 이런 경우 교착상태에 빠진 트랜잭션들 중 하나를 강제로 중지시킵니다. 이때 중지 시킨 트랜잭션은 UNDO즉 변경한 데이터를 원래 상태로 되돌려 놓아야 합니다. 나머지 하나는 정상적으로 실행이 되어 데이터베이스에 변경작업이 이뤄지게 됩니다. 

<br/>

<br/>

#### 트랜잭션 고립 수준

<br/>

위의 락을 통해서 쓰기 - 쓰기에 대한 갱신손실 문제를 해결할 수 있습니다. 그리고 당연하게도 읽기 - 쓰기에 대한 문제도 락으로 해결할 수 있습니다. 그래서 공유락과 배타락이 존재하고요. 하지만 뭔가 아쉽습니다. 읽기와 쓰기에 대해서 락을 사용해서 접근하지 못하게 한다면 두 트랜잭션에 동시 진행 정도를 과도하게 막기 때문입니다. 그래서 나온 조금 더 완화된 방법이 **트랜잭션 고립 수준**입니다 . 좀 더 자세히 알아보도록 하겠습니다.

<br/>

**트랜잭션 고립수준 정의**

<br/>

> 사용자가 트랜잭션의 고립도를 제어할 수 있는 기능을 말하며 트랜잭션 고립수준 명령어를 제공합니다.

<br/>

**읽기와 쓰기에서 발생할 수 있는 문제 **

<br/>

1. 오손 읽기 

   - 오손읽기는 읽기 작업을 하는 트랜잭션이 쓰기 작업을 하는 다른 트랜잭션을 작업 중간에 읽으면서 생깁니다.
   - 쓰기 작업을 한 트랜잭션이 성공적으로 끝나면 문제 없겠지만 중간에 작업이 철회된다면 잘못된 결과가 나타나게 됩니다. 

   <br/>

2. 반복불가능 읽기

   - 반복불가능 읽기는 트랜잭션이 읽기 작업을 하고 다른 트랜잭션이 똑같은 데이터를 변경하고  읽는 트랜잭션이 다시 읽었을 때 똑같은 데이터가 반복되지 않는 것을 의미합니다.
   - 반복불가능 읽기는 문제라고는 할 수 없는 지극히 정상적인 동작입니다. 다만 논리적으로 읽는 동안 변경이 안일어나기를 원할 때 문제가 되는 상황입니다. 

   <br/>

1. 유령데이터 읽기

   - 유령데이터 읽기는 트랜잭션이 읽기 작업을 하고 다른 트랜잭션이 데이터를 넣었을 때 다시 읽는 트랜잭션이 다시 읽었을 때 새로운 데이터가 나타난다는 것을 말합니다.
   - 이것또한 문제라고는 할 수 없는 지극히 정상적인 동작입니다. 다만 논리적으로 읽는 동안 변경이 안일어나기를 원할 때 문제가 되는 상황입니다.

   <br/>

<br/>

이제 위와 같은 세가지 문제를 락보다 완화된 방식인 트랜잭션 고립수준 명령어를 통해서 해결해보도록 하겠습니다. 

<br/>

**트랜잭션 고립수준 명령어**

<br/>

<br/>

| 고립수준        \            문제 | 오손 읽기 | 반복불가능 읽기 | 유령데이터 읽기 |
| --------------------------------- | --------- | --------------- | --------------- |
| READ UNCOMMITTED                  | 가능      | 가능            | 가능            |
| READ COMMITTED                    | 불가능    | 가능            | 가능            |
| REPEATABLE READ                   | 불가능    | 불가능          | 가능            |
| SERIALIZABLE                      | 불가능    | 불가능          | 불가능          |

<br/>

SQL 표준에서는 위와 같이 네 가지 고립 수준을 정의하고 있으나 오라클에서는 READ COMMITTED와 SERIALIZABLE모드만 제공합니다. READ UNCOMMITTED와 REPEATABLE READ모드를 지원하지 않는 이유는 오라클 만의 동시성 제어 알고리즘을 운영하고 있기 때문입니다. 트랜잭션 고립수준 명령어는 데이터를 읽는 트랜잭션의 관점에서 보면 이해가 쉽습니다.

<br/>

1. READ UNCOMMITTED(Level = 0)

   - 고립 수준이 가장 낮은 명령어입니다.
   - 자신의 데이터에 아무런 락을 걸지 않습니다(배타락은 갱신손실 문제 때문에 걸어야 합니다.)
   - 또한 다른 트랜잭션에 공유락과 배타락이 걸린 데이터를 대기하지 않고 읽습니다. 
   - 심지어 다른 트랜잭션이 COMMIT하지 않는 데이터도 읽을 수 있습니다.
   - 이 명령어는 테이블에 대해서 락을 설정하지 않는 것과 같은 상태입니다. 

   **오손 읽기, 반복불가능 읽기, 유령데이터 읽기 모두 발생합니다. **

   <br/>

2. READ COMMITED(Level = 1)

   - 오손 페이지의 참조를 피하기 위해 자신이 데이터를 읽는 동안 공유락을 걸지만 트랜잭션이 끝나기 전에라도 해지가능합니다.
   - 다른 트랜잭션 데이터는 락 호환성 규칙에 따라 진행합니다. (가장 일반적으로 보임, 그래서 오라클의 기본 설정입니다.)

   **반복불가능 읽기, 유령 데이터 읽기가 발생할 수 있습니다. **

   <br/>

1. REPEATABLE READ(Level = 2)

   - 자신의 데이터에 설정된 공유락과 배타락을 트랜잭션이 종료할 때까지 유지하여 다른 트랜잭션이 자신의 데이터를 갱신할 수 없도록 합니다. 
   - 다른 트랜잭션 데이터는 락 호환성 규칙에 따라 진행합니다.
   - 다른 고힙화 수준에 비해 규제가 심해 데이터의 동시성이 낮아 특별한 상황이 아니라면 사용하지 않는 것이 좋습니다.

   **유령 데이터 읽기가 발생할 수 있습니다.**

   <br/>

2. SERIALIZABLE(Level = 3)

   - 고립 수준이 가장 높은 명령어입니다. 
   - 실행 중인 트랜잭션을 다른 트랜잭션으로부터 완벽하게 분리합니다.
   - 데이터 집합에 범위를 지어 잠금을 설정할 수 있기 때문에 다른 사용자가 데이터를 변경하려고 할 때 트랜잭션을 완벽하게 분리할 수 있습니다. 
   - 네가지 고립화 수준 중 제한이 가장 심하고 데이터의 동시성도 가장 낮습니다. 
   - 이 명령어는 테이블에 미리 배타락을 설정한 것과 같은 효과를 나타냅니다.(인덱스에 공유락을 설정하여 다른 트랜잭션의 INSERT 문이 금지됩니다.)

   **어떤 문제도 발생하지 않지만  제한이 심해 성능이 낮아집니다.**

<br/>

### 회복 

<br/>

데이터베이스에 장애가 발생했을 때 데이터베이스를 일관성 있는 상태로 되돌리는 기능을 회복이라고 합니다. 

데이터 베이스에서 발생할 수 있는 장애의 유형은 다음과 같습니다. 

- 시스템 충돌: 하드웨어 혹은 소프트웨어의 오류로 주기억장치가 손실되는 것을 말합니다.
- 미디어 장애: 헤드 충돌이나 읽기 장애로 보조기억장치가 손실되는 것을 말합니다. 보조기억장치에 저장 중인 데이터의 일부 혹은 전부가 손실됩니다. 
- 응용 소프트웨어 오류: 데이터베이스에 접근하는 소프트웨어의 논리적인 오류로 트랜잭션의 수행이 실패하는 것을 말합니다.

위의 장애들은 변경 중인 데이터를 갖고 있는 주기억장치의 손실을 일으키거나 데이터베이스가 저장된 하드디스크를 손실시킵니다. 

<br/>

**트랜잭션과 회복**

<br/>

트랜잭션은 데이터베이스의 회복의 단위입니다. 트랜잭션은 데이터의 변경 내용을 한순간에 모두 데이터베이스에 기록하지 않습니다. 일단 변경한 내용(버퍼)을 로그(임시 디스크)에 기록한 후 데이터베이스에 반영합니다. DBMS의 회복관리자는 트랜잭션의 ACID성질 중 원자성과 지속성을 보장하여 장애로부터 데이터베이스를 보호합니다. 

장애가 발생하면 로그의 내용을 참조하여 트랜잭션의 변경 내용을 모두 반영하거나 아니면 아예 반영하지 않는 방법으로 원자성을 보장합니다. 지속성도 마찬가지입니다. 트랜잭션이 일단 COMMIT한 내용은 로그를 이용하여 반드시 데이터베이스에 기록합니다. 그리고 이 로그를 이용하여 부분완료 후에 데이터베이스에 기록하는 과정에서 문제가 발생해도 로그를 활용해 완료시킬 수 있습니다. 

<br/>

**로그 파일**

<br/>

DBMS는 트랜잭션이 수행 중이거나 수행이 종료된 후 발생하는 데이터베이스 손실을 방지하기 위해 로그 파일을 사용합니다.

로그 파일은 트랜잭션이 반영한 모든 데이터의 변경사항을 데이터베이스에 기록하기 전에 미리 기록해두는 별도의 데이터베이스입니다. 안전한 하드디스크에 저장되며 전원과 관계없이 기록이 남아 있습니다. 

로그의 구조는 다음과 같습니다. 

<트랜잭션번호, 로그의 타입, 데이터 항목 이름, 수정 전 값, 수정 후 값>

<br/>

트랜잭션은 '시작 - 수행 - 부분완료 - 완료'상태를 거치는데, 수행 중에 변경된 데이터는 주기억장치의 버퍼에 기록됩니다. 그리고 데이터의 변경이 일어날 때마다 변경 내용은 로그 파일에 저장됩니다. 

로그파일이 변경되는 시점은 **즉시갱신**인지, **지연갱신**인지에 따라서 다릅니다. 

<br/>

- 즉시 갱신
  - 즉시 갱신은 버퍼 -> 로그파일, 버퍼 ->데이터베이스 작업이 부분완료 전에 동시에 진행될 수 있으며, 부분완료 전에 버퍼의 갱신 데이터는 로그에 기록이 진행된 상태이며 부분완료 전에 버퍼의 일부 내용이 실제 데이터베이스에 적용될 수 있습니다. 

<br/>

- 지연 갱신
  - 지연 갱신은 버퍼 -> 로그파일이 끝나고 버퍼 -> 데이터베이스 작업을 진행하는 방법입니다. 부분완료 전에는 갱신 내용이 실제 데이터베이스에 반영이 되지 않은 상태입니다. 

<br/>

**트랜잭션의 재실행**(**REDO**)

<br/>

| 로그번호 | 로그 레코드     |
| -------- | --------------- |
| 1        | [T1, START]     |
| 2        | [T1, UPDATE...] |
| 3        | [T1, UPDATE...] |
| 4        | [T1, COMMIT]    |
| 5        | [T2. START]     |
| 6        | [T1, UPDATE...] |
| 7        | [T1, UPDATE...] |
| 8        | [T1, UPDATE...] |
| 9        | [T2. COMMIT]    |

<br/>

장애가 발생한 후 시스템을 다시 가동을 했을 때, 로그 파일에 트랜잭션의 START가 있고 COMMIT이 있을 경우 트랜잭션이 모두 완료되었다는 뜻입니다. 다만 변경 내용이 버퍼에서 데이터베이스에 기록되지 않았을 가능성이 있기때 때문에, 로그를 보면서 트랜잭션이 변경한 내용을 데이터베이스에 다시 기록하는 과정이 필요합니다. 이를 **REDO**라고 합니다.

<br/>

<br/>

**트랜잭션의 취소(UNDO)**

<br/>

장애가 발생한 후 시스템을 다시 가동했을 때, 로그 파일에 트랜잭션의 START만 있고 COMMIT이 없는 경우 트랜잭션이 완료되지 못했다는 의미로 트랜잭션이 한 일을 모두 취소해야 합니다. 이 경우 완료하지 못했지만 버퍼의 변경내용이 데이터베이스에 기록되어 있을 경우가 있기 때문에 로그를 보면서 트랜잭션이 변경한 내용을 데이터베이스에서 원상복구시켜야합니다. 이 과정을 **UNDO**라고 합니다.

<br/>

트랜잭션이 **지연갱신이든 즉시갱신이든  REDO**라면 똑같이 실행하면 됩니다. 하지만 **UNDO**라면 지연갱신은 COMMIT전에는 데이터베이스에 기록을 하지 않기 때문에 **UNDO과정을 거칠 필요가 없습니다**. 즉 데이터에 반영하는 시점은 미루지만 연산을 감소시킬 수 있습니다. 

<br/>

<br/>

**체크 포인트를 이용한 회복**

<br/>

로그를 이용한 회복은 시스템에 장애가 일어났을 때 어느 시점까지 되돌아가야 하는지 알 수가 없습니다. 트랜잭션이 많은 응용의 경우 하루 이상 되돌아가서 복구하는 것은 사실상 불가능합니다. 트랜잭션이 많이 일어나는 프로그램일 경우 하루 이상 되돌아가서 복구하는 것은 사실상 불가능합니다. 그래서 회복 시 많은 양의 로그를 검색하고 갱신하는 시간을 줄이기 위하여 몇 십 분 단위로 데이터베이스와 트랜잭션 로그 파일을 동기화한 후 동기화한 시점을 로그 파일에 기록해두는 방법 혹은 그 시점을 체크포인트라고 합니다. 

<br/>

체크포인트 시점에는 다음과 같은 작업을 합니다. 

- 주기억장치의 로그 레코드를 모두 하드디스크의 로그 파일에 저장한다. 
- 버퍼에 있는 변경된 내용을 하드디스크의 데이터베이스에 저장한다
- 체크포인트를 로그 파일에 표시한다. 

<br/>

체크 포인트가 있으면 로그를 이용한 회복 기업은 좀 더 간단해집니다. 

<br/>

1. 체크포인트 이전에 COMMIT기록이 있는 경우 

   아무 작업이 필요없습니다. 이미 트랜잭션이 데이터베이스에 적용되었기 때문에

<br/>

1. 체크포인트 이후에 COMMIT 기록이 있는 경우(즉시갱신, 지연갱신 모두) 

   REDO를 진행합니다. 체크포인트 이후에 변경 내용이 데이터베이스에 반영되지 않았을 가능성이 있으므로.... 

<br/>

1. 체크포인트 이후에 COMMIT기록이 없는 경우 (즉시갱신, 지연갱신에 따라 다름)

   지연갱신의 경우 아무 작업이 필요없습니다. COMMIT되기전 까지 데이터베이스에 적용되지 않습니다. 

   START가 찍히고 COMMIT이 찍히기 전일 때 버퍼에 있는 변경된 내용을 하드디스크의 데이터베이스에 저장할 수 있습니다. 그렇기 때문에 UNDO를 진행해야 합니다.

<br/><br/>



### 참고자료 

<br/>

<br/>

IT CookBook, 오라클로 배우는 데이터베이스 개론과 실습





