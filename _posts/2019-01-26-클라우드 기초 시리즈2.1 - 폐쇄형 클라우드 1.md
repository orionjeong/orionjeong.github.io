---
layout: post
title:  클라우드 기초 시리즈2.1 - 폐쇄형 클라우드1 
date:   2019-01-24
description: 폐쇄형 클라우드 정의와 예시에 대한 내용입니다.
tags: [클라우드, cloud, 기초, 폐쇄형 클라우드 ]
category: 클라우드
---


<br/>

클라우드 기초 시리즈1 - 개념정리에서는 클라우드의 정의와 종류에 대해서 다뤄봤는데요, 클라우드 기초 시리즈2에서는 1에서 배운 종류에 대해 더 자세히 배우는 차원에서 사용형태에 따른 분류 중 폐쇄형 클라우드에 대해서 알아보도록 하겠습니다. 이번 포스트에는 kakao if컨퍼런스에서 배운 내용을 참조하면서 작성하였습니다. 

<br/>
<br/>
<br/>
#### 폐쇄형 클라우드 정의
<br/>
폐쇄형 클라우드를 다시 한 번 정의하자면 이렇습니다. 

> 기업 내부의 비밀을 유지하기 위해 외부에 공개되지 않도록 회사 내에서만 사용할 수 있는 클라우드 서비스를 말한다.

즉 클라우드는 클라우드인데 회사 내에서만 쓸 수 있는 클라우드를 말합니다.

<br/>
<br/>
<br/>

#### 폐쇄형 클라우드가 나오게 된 이유
<br/>
왜 이런 개념이 나오게 되었는지 시나리오를 바탕으로 살펴보도록 하겠습니다. 
<br/>
1. 회사원 A는 kakao를 다니고 있고 이번에 처음으로 신규 프로젝트를 진행하게 되었습니다.
<br/>
2. 팀원들과 회의를 통하여 필요한 컴퓨팅 자원들을 산출하고 이를 담당하는 인프라 팀에 자원을 요청하였습니다. 
<br/>
3. 자원에 대해서는 민감하기 때문에 결제가 되기를 기다립니다. 승인은 났지만 자원을 구매하고 배송되기까지 오랜 시간이 지체 됩니다.
<br/>
4. 컴퓨팅 자원들이 드디어 도착하였습니다. 이제 이 자원들을 설치하고 그 안에 개발을 위한 셋팅을 해야합니다. 
<br/>
5. OS를 설치하고 필요한 tool들을 설치합니다. 
<br/>
6. 개발을 위한 프레임워크들을 설치합니다. 
<br/>
7. 나중을 위해 개발서버, 운영서버가 따로 필요합니다. 
<br/>
8. A 팀은 개발과 운영을 동시에 해야합니다. CI(지속적인 통합)이 필요합니다.
<br/>
9. jenkins, github를 이용하여 자동 배포 환경을 만듭니다. 
<br/>
10. 이제 다 만들었네요!! 운영서버에 배포를 하게되고 서비스를 하게됩니다.
<br/>
11. 이런 오류가 나서 하루동안 서비스가 돌아가지 않고 있었습니다. 
<br/>
12. 시말서를 작성할 상황이네요... 오류가 나면 바로 알아차릴 수 있도록 에러모니터링 기능을 추가합니다.
<br/>
13. 이제 에러가 나면 바로 카톡으로 알림이오네요. 정말 다행입니다. 
<br/>
14. 이런... 사용자가 많아져서 서버가 과부하가 걸립니다. 서버 확장을 위해서 위에서 처럼 필요한 컴퓨팅 자원들을 산출하고 인프라팀에 자원을 요청합니다... 등등등
<br/>
<br/>


클라우드를 사용하기 전 On-premise(자원을 직접 설치해 운영하는 방식)방식에서의 레거시가 한 눈에 보이시나요? 위의 A같은 팀이 여러팀이 있다면요?? 아니면 서버를 이전해야한다면요?? 어마어마한 자원낭비가 발생할 것입니다. 그렇다고 AWS같은 개방형 클라우드를 쓰기에는 회사의 보안때문에 불안합니다. 이런 경우 회사가 능력이 있다면 자체 폐쇄형 클라우드를 구축하여 제공할 수 있습니다. 

<br/>
<br/>
<br/>
#### 카카오의 폐쇄형 클라우드 
<br/>
<br/>
<br/>
**IaaS(Infrastructure as a service)**

<br/>

카카오도 위의 시나리오처럼 On-premise방식의 레거시를 가지고 있었습니다. 이는 크나큰 인적 자원낭비로 이어질 수 있습니다. 그래서 카카오는 팀을 구성하여 폐쇄형 클라우드를 만들게 됩니다. 정확한 목적은 개발자원에 한해서 카카오 내부적인 셀프 서비스를 만들기였습니다.

<br/>

그렇게 카카오의 폐쇄형 클라우드중 IaaS로 만들어진 서비스의 이름은 krane이며 오픈스택 기반의 클라우드 서비스입니다.
<br/>
많은 클라우드들의 기반이 되는 오픈소스들은 나중에 포스트하도록 하겠습니다.

<br/>

krane은 밑의 구조를 가지고 있습니다. 

![image-20190126161301888](/assets/img/image-20190126161301888.png)

<br/>

여기서 베어메탈은 오픈스택기반의 클라우드에서 자주 볼 수 있는데 풀이하자면 물리서버 하나를 제공한다고 볼 수 있습니다. 이런 면에서 어떻게 보면 일반적인 웹호스팅이랑 비슷하네요. 그리고 나머지 VM, 로드밸런싱, DB를 제공해주는 전형적인 IaaS입니다. 부가적으로 DNS 설정, 인증기능, IMS 정보관리 시스템을 제공해주고 있습니다.

<br/>
<br/>
**MaaS(Monitoring as a service)**

<br/>

카카오의 IaaS 서비스 크레인은 편리하기에 많은 사람들이 사용했다고 합니다. 그리고 개발서버 뿐만 아니라 운영서버에서도 이용할 수 있도록 해달라는 요구사항도 들어왔습니다. 

<br/>

이에 카카오에서는 운영서버로 이용하기 위해서는 모니터링기능이 꼭 추가되어야 된다고 생각했습니다. 이에 Kemi를 만들게 됩니다. 

<br/>

kemi는 밑의 구조를 가지고 있습니다.

![image-20190126163313489](/assets/img/image-20190126163313489.png)


<br/>


kemi는 카카오의 전사 리소스 모니터링 시스템이라고 합니다. 간단히 구조를 살펴보겠습니다.
<br/>
kemi는 서버 리소스의 메트릭 데이터를 수집해서 보여주고 설정한 임계치에 따라 알림을 보내주는 kemistate와 ETL(추출, 변환, 적재)을 통해 수집한 log를 대시보드 형태로 보여주거나 실시간 알림을 할 수 있는 kemi log로 구성되어 있습니다.

<br/>

더 자세한 로직을 살펴볼까요?
<br/>
Kemi Stats에 대한 자세한 설명입니다.



![image-20190126164017165](/assets/img/image-20190126164017165.png)


<br/>
kemi-stats는 수만대에 이르는 카카오의 전체서버와 컨테이너 서비스를 모니터링 하는데 이용되고 있다고 합니다. poling방식과 push방식 두가지를 사용하고 있는데요, 리로스중 서버의 경우 polling방식으로 snmp를 이용하여 시스템 메트릭을 수집합니다. snmp를 선택한 이유는 서버의 운영체제와 상관없이 모니터링을 하기위해서라고 하네요. 
<br/>


polling방식은 젠킨스 배치job이 시작되면 kemi의 job producer가 IMS(카카오 인프라 관리 시스템)에서 데이터를 가져올 대상을 받아와서 kafka의 polling job queue topic에 넣어높습니다.(이렇게 매 주기 호스트 목록을 가져오는 이유는 서버가 추가되거나 빠지는 걸 바로 반영하기 위해서입니다.) 그다음 polling job queue topic을 보고있던 kemi의 poller가 각 대상들에서 시스템 매트릭을 가져와서 다시 kafka에 저장합니다. 이 데이터를 kemi의 metic calculator가 계산을 해서 다시 kafka에 넣게 됩니다. 

<br/>

push방식은 컨테이너 리소스 모니터링과 snmp가 지원되지 않는 서버에서 이용되고 있습니다. 매트릭 데이터를 kemi의 state agg로 push, 이 데이터를 kafka에 저장, 이후는 똑같습니다.
<br/>


준비된 최종 데이터는 Kemi의 metric forwarder를 통해서 openTSDB에 저장됩니다.(Open TSDB에 들어간 데이터는 Grafana를 이용하여 사요자들이 그래프 형태로 볼수 있게 됩니다.)

<br/>

Kemi Event Alert를 통해서 etcd에 정해진 룰에 따라 알람 이벤트를 생성하여 다시 kafka에 넣습니다.(CPU 사용량이 90% 이상이라던가 네트워크 트래픽이 떨어졌다던가 할 때 개별 호스트 단위/여러 호스트를 묶은 서비스 단위로 알람 이벤트를 생성할 수 있습니다.)

<br/>

Kemi Event Handler는 kafka에 생성된 알람 이벤트를 가지고 kakaotalk, custom api 호출 등 알람 서비스를 제공합니다 .

<br/>
<br/>
<br/>

다음은 Kemi log에 대한 자세한 설명입니다.

![image-20190126165054378](/assets/img/image-20190126165054378.png)

kemi -log는 각 서비스에서 발생한 로그를 모아서 저장하고 보여주는 기능과 설정된 룰에 따라 알람을 발생시킵니다. 서비스 별 로그의 경우 각 서버에 설치된 fluentd를 이용하고 syslog나 네트워크 관련로그는 syslog의 target 설정을 통해 consul domain으로 엮여진 kemi aggregator로 전달됩니다. 

<br/>

이렇게 보내진 데이터는 kemi-log에 aggregator역할을 해주는 fluentd 서버 그룹들이 받은 다음에 그 로그들을 각각 hadoop, kafka에 넣어줍니다.

<br/>

hadoop에 저장된 데이터는 hive batch job을 통해 주기적으로(5~15분) elastic search cluster로 indexing되며 kibana를 통해 사용자가 조회할 수 있게 됩니다.

<br/>

kafka에 저장된 데이터는 etcd의 알람 룰과 storm, redis를 활용해 개발된 kemi dike를 통해 실시간으로 알림을 발생시킵니다.

<br/>

여기까지 폐쇄형 클라우드 정의와, kakao의 IaaS, MaaS 사례였습니다. 글이 너무 길어지기 때문에 다음 포스트에서 클라우드 기초 시리즈2-2로 찾아오도록 하겠습니다.
추가로 https://if.kakao.com/program 여기에 들어가시면 if 컨퍼런스에서 발표했던 pdf자료 및 동영상자료를 볼 수 있습니다 ㅎㅎ 참고하세요~


<br/>
<br/>
<br/>

#### 참고자료

https://mk.kakaocdn.net/dn/if-kakao/conf2018/Kakao%20Cloud%20Native%20Platform,%209rum.pdf
https://if.kakao.com/program