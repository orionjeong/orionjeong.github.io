---
layout: post
title:  DB 기초 시리즈4 - DB트랜잭션
date:   2019-03-03
description: DB 기초 시리즈4로 DB 트랜잭션에 대한 설명입니다.
tags: [DB, Databases, 기초, DBMS, transaction, 트랜잭션]
category: [DB, 면접]
---

DB기초 시리즈4 - DB트랜잭션에 대한 내용입니다. 

오라클로 배우는 데이터베이스 개론과 실습의 책내용 및 여러 블로그분들과 DB가이드 사이트가 많은 도움이 되었고 이를 요약하고 개인적으로 정리한 내용들입니다. 많은 피드백을 환영합니다.

<br/>

### 정의 

db트랜잭션의 정의를 먼저 설명하겠습니다. db트랜잭션이란 하나의 논리적인 작업 단위를 구성하는 일련의 연산들의 집합을 이며 더 이상 나눌 수 없는 업무 처리의 단위입니다. 

<br/>

왜 DB에는 트랜잭션이라는 개념이 존재할까요? 당연히 무결성을 만족하기 위해서인데요, 이를 위해서는 장애나, 여러 트랜잭션이 동시에 진행될 시 작업의 단위를 형성하여 무결성을 위해 노력해야 합니다. 이런 단위를 트랜잭션이라고 합니다.

<br/>

이를 위해 **db트랜잭션은(더 이상 나눌 수 없는 업무 처리의 단위)는 ACID 4가지 특성을 만족**해야합니다. 그래야 무결성을 만족시킬 수 있으니까요

<br/>

<br/>

### 트랜잭션의(ACID) 특성 

<br/>

| 특징                | 기본 개념                                                    |
| ------------------- | ------------------------------------------------------------ |
| Atomicity(원자성)   | - 원자처럼 더는 쪼개지지 않는 단위로 동작해야 한다는 것을 의마합니다. 즉 트랜잭션의 모든 연산들은 정상적으로 수행 완료되거나 아니면 전혀 어떠한 연산도 수행되지 않은 상태를 보장해야 합니다(하나의 단위이기 때문에). 트랜잭션 중간에 작업이 잘못되면 회복 알고리즘으로 변경한 내용을 취소합니다(자의적으로 할 경우 ROLLBACK연산을 사용). |
| Consistency(일관성) | - 트랜잭션 완료 후에도 데이터베이스가 일관된 상태로 유지되어야 합니다. (ex 명시적인 무결성 제약조건과 같은 특성이 유지되어야 함, A계좌와 B계좌 사이의 거래 후 둘을 더한 총 금액은 똑같아야 한다는 비명시적인 일관성 조건 존재.)  명시적인 경우 DBMS에서 관리하지만 비명시적인 일관성조건(거래 후 둘의 총합이 거래 전과 달라지는 경우)는 DB사용자에 의해 관리됩니다. |
| Isolation(독립성)   | 어떤 트랜잭션이 동시에 수행되더라도 각각의 트랜잭션은 다른 트랜잭션의 수행에 영향을 받지 않고 독립적으로 수행되어야 합니다. 가장 손쉽게 독립성을 지킬 수 있는 방법은 모든 트랜잭션을 순차적으로 수행하는 것이다. (각 트랜잭션간의 독립성이 보장되어야 한다. ) 고립성을 지키지못하면 비명시적인 일관성같은 일관성이 깨질 수 있기 때문에 고립성을 가져야하는데 이를 위해서 트랜잭션의 동시성을 제어해야하고 이를 동시성 제어라고 합니다. 동시성 제어보다 완화된 방법으로는 트랜잭션 고립수준에 따라 트랜잭션의 상호작용을 완화시키는 방법도 존재합니다. |
| Durability(지속성)  | 트랜잭션이 성공적으로 완료되어 커밋되고 나면, 해당 트랜잭션에 의한 모든 변경은 향후에 어떤 소프트웨어나 하드웨어 장애가 발생되더라도 보존되어야 한다. 다른 트랜잭션이 성공적으로 완료되어 변하기 전까지는 어떠한 장애에 의해서도 변하면 안되기 때문에서 모든 성공한 트랜잭션은 기록을 남긴다. 이를 위해 많은 데이터베이스의 구현에서는 트랜잭션 조작을 하드 디스크에 '로그'로 기록하고 시스템에 이상이 발생하면 그 로그를 사용해 이상 발생 전의 상태까지 복원하는 것으로 지속성을 실현시킵니다. |

<br/>

<br/>

### DB트랜잭션 진행과정 및 ACID가 지켜지지 않는 예

<br/>

위의 ACID 성질을 가지지 못했을 때의 결과를 알아보기 전 DB트랜잭션의 진행과정을 알아보도록 하겠습니다. 

<br/>

**DB트랜잭션 진행과정**

<br/>

데이터베이스의 데이터는 하드디스크에 저장되어 있습니다. 이를 처리하기 위해서는 반드시 주기억 장치 버퍼로 사본을 읽어와야 합니다. 그리고 이를 DBMS가 중간에서 관리합니다. 

<br/>

여기에 아래와 같은 예가 있습니다.

```sql
START TRANSACTION

UPDATE Customer
SET balance = balance - 5000
WHERE name = '김아무개';

UPDATE Customer
SET balance = balance + 5000
WHERE name = '이아무개';

COMMIT
```

<br/>

위의 작업은 두 가지의 데이터 수정작업이 존재하지만 실제 트랜잭션을 수행할 때는 먼저 김아무개의 계좌를 읽어오고 이아무개의 계좌를 읽어와 잔고를 확인하는 작업이 두 가지가 먼저 존재하고 데이터 수정작업 두개가 후에 이뤄집니다. 여기서 끝난 것이 아닙니다. COMMIT명령어에 의해 부분적 완료가 되었고 데이터베이스에 기록이 되어야 완전한 COMMITTED상태가 되기 때문에 김아무개와 이 아무개의 계좌에 기록되는 두가지의 작업이 더 존재합니다. 즉 총 6개의 작업이 존재합니다.  **이렇게 부분적 완료가 존재하는 이유는 데이터베이스에 기록을 하는 작업을 DBMS에 권한을 넘겨주기 때문입니다.** 데이터베이스에 기록을 하는 작업은 시간이 오래걸립니다. 권한을 넘겨줌으로써 각각의 트랜잭션이 하드디스크에 개별접근하는 것을 피하고 DBMS가 다른 트랜잭션의 작업 처리 상황을 봐가면서 일괄적으로 하드디스크에 접근하여 처리함으로써 사용자에게 빠른 응답성을 보장하기 위해서입니다.  

<br/>

**ACID가 지켜지지 않는 예**

<br/>

트랜잭션이 안전하게 실해되려면 ACID 같은 특징을 가지고 있어야 한다고 했는데요, 어떤 경우에 위와 같은 특징을 가지지 못할까요?  위에서 봤던 예제를 활용해 보겠습니다. 

1. 김아무개와 이아무개가 거래를 하려고 합니다. 
2. 김아무개의 잔액확인, 이아무개의 잔액을 확인합니다.
3. 김아무개의 잔액을 -5000원 합니다. 
4. 이아무개의 잔액을 +5000원 해야하는데 시스템 오류(이아무개에게 돈은 보냈지만, 김아무개에서의 처리가 끝나지 않은 상황에서 종료)가 발생합니다. 

<br/>

위와 같은 상황을 볼 때 A는 자신의 돈을 보내고 뺏지만 B는 돈을 받지 못한 상황이 됩니다. 즉 원자성을 위반하고, 비명시적인 일관성 조건(둘의 총 금액을 더한 값은 그 이전과 같아야 한다.)을 위반하여 일관성도 위반하게 됩니다. 또한 COMMIT이 되지 않았는데 전에 COMMIT된 상태에서 데이터가 변경되었기 때문에 지속성도 위반하였습니다. 

<br/>

이경우는 어떨까요?

1. 김아무개와 이아무개가 거래를 하려고 합니다. 
2. 김아무개의 잔액확인, 이아무개의 잔액을 확인합니다.(김아무개 잔액 5000, 이아무개 잔액 5000)
3. 근데 이때 조아무개가 갑자기 김아무개에게 10000원을 주기 위해서 조아무개와 김아무개의 잔액을 조사합니다.(김아무개 잔액 5000, 조아무개 잔액 10000)
4. 조아무개의 잔액에서 -10000을 합니다.
5. 김아무개의 잔액에서 +10000을 합니다. (확인 된 잔액 5000원 이었음 + 10000이니 15000원이 됨)
6. 김아무개는 이아무개에게 돈을 주기위해 자신의 계좌에서 -5000을 합니다.(이 아무개에게 줄 때의 잔액은 5000임) 그래서 김아무개의 잔액은 최종적으로 0원이 됨
7. 이아무개의 잔액은 + 5000이 되서 10000이 됨
8. 김아무개의 잔액은 원래 15000 - 5000  = 10000이 되어야 하지만 0이 되는 대참사가 일어남 

<br/>

위와 같은 상황은 일단 독립성위반입니다. 하나의 트랜잭션이 동작하고 있을 때 독립적으로 동작하지 못해 서로 다른 트랜잭션끼리 잘못된 영향을 주었습니다. 또 일관성을 위반하였습니다. 서로간의 거래를 통한 총 금액은 똑같아야 하는데 현재 잘못된 100만원이 더 추가된 상황입니다. 

<br/>

또 다른 경우입니다. 데이터베이스가 이상종료되면서 데이터베이스의 자료가 다 날라간 상황이지만 복구할 방법이 없습니다. 지속성 위반입니다 .

<br/>

트랜잭션은 db의 무결성을 만족하기 위해 위의 ACID성질들이 지켜지도록 설계되고 구현되어야 합니다. ACID가 안지켜진 경우 위의 예처럼 문제가 생길 수 있으며 트랜잭션이라고 할 수 없습니다. 

<br/>

<br/>

### 트랜잭션 연산

<br/>

트랜잭션을 수행하기 위해서는 트랜잭션 연산을 수행해야 하는데요, CMMIT연산과 ROLLBACK연산이 있습니다. 

<br/>

**commit**
<br/>
 트랜잭션 처리가 정상적으로 종료되어 트랜잭션이 수행한 변경 내용을 데이터베이스에 반영시킨다는 연산입니다. (상태는 부분적 완료를 나타냄)

<br/>

**rollback** 
<br/>
트랜잭션 처리가 비정상적으로 종료되어 데이터베이스의 일관성이 깨졌을 때 트랜잭션이 행한 모든 변경 작업을 취소하고 이전 상태로 되돌리는 연산입니다. rollback연산 시 해당 트랜잭션은 받았던 자원과 잠금을 모두 반환하고, 재시작되든지 폐기 됩니다. 트랜잭션 수행중 잘못될 경우 DBMS에서 알아서 ROLLBACK을 일으키고 프로그래머가 명시적으로 특정상황에 ROLLBACK연산을 이용할 수도 있습니다. 

<br/><br/>

### 트랜잭션 상태

<br/>

트랜잭션이 수행되는 과정에서 상태는 5가지 상태가 있습니다. 

![image-20190303141233191](/assets/img/image-20190303141233191.png)

<br/>

1. 활동(active) - 트랜잭션이 현재 실행중인 상태를 나타냅니다.
2. 부분 완료(partially committed) - 실행을 마치고선 데이터 베이스에 결과를 저장하기 직전의 상태를 나타냅니다.
3. 완료(committed) - 트랜잭션의 변경 내용을 성공적으로 저장한 상태를 나타냅니다.
4. 실패(failed) - 트랜잭션 실행 중 오류가 난 상태를 나타냅니다.
5. 철회(aborted) - ROLLBACK명령어를 통해 트랜잭션의 수행 이전 상태로 돌린 상태를 나타냅니다.

<br/>

위에서 다른 것들은 다 잘 이해가 가지만 부분완료와 완료가 나뉜 부분이 이해가 안가 추가 설명을 합니다. 

먼저 프로그래머가 실행한 트랜잭션은 COMMIT연산에 의해 수행이 완료됩니다. 하지만 아직 트랜잭션에 의한 변경 내용이 주기억장치 버퍼에만 저장되어 있는 상태로 이를 하드디스크에 있는 데이터베이스에 기록해야합니다. 이는 DBMS가 수행합니다. 그리고 이게 완료되면 committed상태가 됩니다. 그럼으로 활동에서 실패로 가는 경우는 트랜잭션 동작 중 연산이 실패한 경우고 부분 완료에서 실패로 가는 경우는 트랜잭션의 수행은 성공적으로 맞췄지만 데이터베이스에 기록하는 과정에서 실패한 경우입니다. 

<br/>

<br/>

### 트랜잭션과 DBMS

<br/>

DBMS는 트랜잭션이 원자성, 일관성, 고립성, 지속성을 유지하 수 있도록 지원합니다. 그에 대한 간단한 내용을 살펴보도록 하겠습니다.

<br/>

**DBMS의 원자성을 위한 지원**

<br/>

DBMS는 원자성을 지원하기 위해서 회복(복구) 관리자 프로그램을 작동시키고 있습니다. 회복 관리자 프로그램은 데이터베이스가 변경한 내용을 로그로 기록하고 있다가 트랜잭션에 문제가 생겼을 때 원래 상태로 되돌립니다. 

<br/>

**DBMS의 일관성을 위한 지원**

<br/>

DBMS는 일관성을 지원하기 위해서 무결성 제약조건을 활용합니다. 데이터에 변경이 생기면 미리 정의해 둔 무결성 제약조건을 검사하여 일관성이 깨지는 것을 막습니다. 또한 두 개의 트랜잭션이 동시에 수행 될 때 트랜잭션 간에 간섭으로 일관성이 깨지는 경우를 위해 트랜잭션들이 질서 있게 접근하여 데이터베이스의 일관성을 유지할 수 있도록 동시성 제어 알고리즘을 작동시킵니다. 그 외의 비명시적 일관성(프로그래머가 A, B를 거래 할 때 2만원을 주면 2만원을 빼는 식으로 해야하는데 3만원을 빼는 등)은 프로그래머에 의해 지켜져야 합니다.

<br/>

**DBMS의 고립성을 위한 지원**

<br/>

DBMS는 고립성을 지원하기 위해서 일관성을 유지하는 것과 마찬가지로 동시성 제어 알고리즘을 작동시킵니다. 두 개의 트랜잭션이 동시에 수행될 때 간섭에 의하여 데이터 값이 손상되면 고립성이 깨집니다. 이 경우 동시성 제어 알고리즘을 작동시켜 여러 트랜잭션에 문제가 있을 때 원 상태로 되돌립니다. 

<br/>

**DBMS의 지속성을 위한 지원**

<br/>

DBMS는 지속성을 유지하기 위해서 회복 관리자 프로그램을 이용합니다. 회복관리자 프로그램은 데이터베이스가 변경한 내용을 로그로 기록하고 있다가 트랜잭션의 문제가 생기거나 시스템의 오류로 인해 데이터가 손상되어을 때 데이터베이스를 회복합니다. 

<br/>

<br/>

즉 DBMS에서는 트랜잭션을 위해서 많은 지원을 하고 있는데 회복(복구)프로그램, 동시성 제어 알고리즘, 트랜잭션 고립 수준, 무결성 제약조건이 대표적입니다. 이 들을 다음 포스트에서 하나씩 알아보도록 하겠습니다.









