---
layout: post
title:  DB 기초 시리즈1 - DB인덱스
date:   2019-01-28
description: DB기초 시리즈의 DB인덱스에 대한 설명입니다. 
tags: [DB, Databases, 기초, DBMS, 인덱스 ]
category: DB
---

## DB인덱스

면접에서 DB인덱스는 단골질문입니다. 개념을 알고만 있으면 안됩니다. 원리를 알고 있어야 합니다.

저도 이번 post를 토대로 DB인덱스를 완전히 이해해보려합니다.



위키 정의를 한 번 살펴보겠습니다 

> **인덱스**(영어: index)는 데이터베이스 분야에 있어서 테이블에 대한 동작의 속도를 높여주는 자료 구조를 일컫는다. 고속의 검색 동작뿐만 아니라 레코드 접근과 관련 효율적인 순서 매김 동작에 대한 기초를 제공한다.

위키 정의의 느낌으로는 특정지점에 빠르게 접근할 수 있는 방법이라고 말하고 있는 것 같습니다.



조금 더 자세한 예시를 살펴보도록 하겠습니다.

```SQL
select content from board where title = "DB인덱스"
```

DBMS를 프로젝트에서 한 번이라도 써보셨다면 써보았을 평범한 쿼리문입니다. 누구나 알고 있고요. 혹시 이 쿼리문이 어떤식으로 동작하는지 생각해보신적 있나요? 대부분이 그냥 지나치기 마련입니다. 그래서 이번 기회에 완벽히 파악해보도록 하겠습니다.



#### DB 인덱스

인덱스는 쉽게 말하면 사전의 인덱스와 다르지 않습니다. 사전에서 단어를 찾을 때 우리는 A, B, C, D가 적힌 인덱스를 보면서 Database라는 단어를 조금 더 쉽게 찾을 수 있습니다. 만약 사전에 인덱스가 없다면 모든 사전을 다 찾아보고 Databases를 찾을 수 있을 것입니다. 어느방법이 더 빨라 보이나요? 당연히 인덱스를 이용하는 방법이 더 효율적이고 빠릅니다.

여기서 주의할 점이 있습니다. index가 마냥 좋은 것은 아닙니다. 인덱스는 table마다 여러개를 생성할 수 있는데요, update, insert, delete를 할 때마다 테이블의 변경 뿐만 아니라 index의 변경도 이루어지기 때문에 오히려 늦어질 수 있습니다.



#### 구조에 따른 인덱스 종류

------

구조에 따른 인덱스 종류로는 

##### B-Tree 인덱스, BitMap 인덱스, B+Tree 등이 있습니다

여기서는 DBMS에서 가장 일반적인 인덱스인 B-Tree 인덱스를 다뤄보도록 하겠습니다.



![image-20190129231927124](/assets/img/image-20190129231927124.png)

그림 참고 http://www.dbguide.net/db

브랜치 블럭은 분기를 목적으로 합니다. 여기서 가장 중요한 것은 Leaf Block입니다. Leaf Block안에는 인덱스를 구성하는 칼럼의 데이터와 해당 데이터를 가지고 있는 행의 위치를 가리키는 레코드 식별자로 구성되어 있습니다. 리프 블록은 양방향 링크를 가지고 있습니다. 이것을 통해서 오름 차순, 내림 차순 검색을 쉽게 할 수 있습니다. 인덱스는 해당 칼럼 데이터로 정렬된다. 만약 인덱스 데이터의 값이 같으면 레코드 식별자의 순서로 저장된다.  B -Tree인덱스는 "=", BETWEEN, 등과 같은 연산자로 검색하는 범위 검색에 적합하다고 합니다. 이제 어느정도 원리를 알았으니 더 자세한 예를 보도록 하겠습니다.



![image-20190129232630428](/assets/img/image-20190129232630428.png)

그림 참고 http://www.dbguide.net/db

위와 같은 인덱스가 있다고 가정합니다. 원하는 값을 찾는 과정을 살펴봅시다.

1단계입니다. 브랜치 블록의 가장 왼쪽 값이 찾고자 하는 값보다 작거나 같으면 왼쪽 포인터로 이동합니다. 

2단계입니다. 찾고자 하는 값이 브랜치 블록의 값들 사이에 존재한다면 가운데 포인터로 이동합니다. 

3단계입니다. 찾고자 하는 값이 오른쪽에 있는 값보다 크면 오른쪽 포인터로 이동합니다.

위와 같은 과정을 찾을 때까지 반복합니다.

원하는 값을 찾게 된다면 레코드 식별자를 이용해서 테이블을 액세스하여 원하는 데이터들을 가져올 수 있습니다.



#### 저장 형태에 따른 인덱스 종류

------



##### 클러스터형 인덱스

SQL Server의 인덱스 종류는 저장 구조에 따라 클러스터형 인덱스와 비클러스터형 인덱스가 있습니다. 여기서 클러스터형을 설명하자면 두 가지 중요한 특징으로 말할 수 있습니다.

1. 리프에 있는 데이터가 곧 전체 데이터입니다. 즉 테이블 row에 있는 모든 데이터를 리프에 가지고 있는 구조입니다. 인덱스에 테이블의 데이터를 전부 가지고 있기 때문에 따로 레코드 식별자가 있을 필요가 없습니다. 테이블에 접근할 필요가 없으니까요. 
2. 리프의 모든 로우는 인덱스 키 칼럼 순으로 물리적으로 정렬되어 저장됩니다. (키가 id인경우 id로 정렬됩니다.) 또한 물리적으로 한 가지 순서로만 정렬될 수 있어서 클러스터형 인덱스는 테이블 당 한 개만 생성할 수 있습니다.(전화번호부  한 권을 인명과, 전화번호로 동시에 정렬 할 수 없는 것처럼)

![image-20190130002442850](/assets/img/image-20190130002442850.png)

그림 참고 http://www.dbguide.net/db

B-Tree 구조를 편의상 왼쪽으로 90도 돌려놓은 모습입니다



##### 비클러스터형 인덱스 

비클러스터형 인덱스는 위의 B-Tree인덱스 구조처럼 클러스터형 인덱스가 아닌 애들을  비클러스터형 인덱스라고 합니다.



##### 클러스터형 인덱스와 비클러스터형 인덱스의 차이

쉽게 말하면 클러스터형 인덱스는 영어사전, 비클러스터형 인덱스는 일반 목차가 있는 책을 생각하시면 됩니다. 영어사전은 A, B, C를 순서로 정렬되어있고, 일반책은 목차를 통해서 관련 페이지로 이동해서 찾게 됩니다. 

클러스터형은 테이블에 인덱스를 한개만 생성할 수 있습니다. 또 클러스터형 인덱스가 걸려있으면 테이블은 자동으로 정렬을 합니다.

비클러스터형은 테이블에 여러개의 인덱스를 생성할 수 있습니다. 



##### 클러스터형 인덱스, 비클러스터형 인덱스 예시

만약 Board 테이블이 있고 board_id가 primary key로 지정하면 자동으로 board_id를 기준으로 클러스터 인덱스가 생성됩니다. 

하지만 테이블을 생성할 때 board_id에 NONCLUSTERED를 옵션으로 주면 비클러스터형 인덱스로 생성할 수 있습니다.



테이블을 만들 때 인덱스가 자동 생성되는 경우는 Primary Key, Unique밖에 없습니다. 그리고 클러스터형 인덱스로 설정할 수 있습니다.  

그 후 인덱스를 따로 만들 수 있으며 클러스터형, 비클러스터형으로 만들 수 있지만, 만약 private key가 있는 테이블이라면 이미 클러스터형 인덱스가 하나 만들어졌기 때문에 비클러스터형 인덱스로 만들어야 합니다. 

억지로라도 private key가 아닌 다른 컬럼에 클러스터형 인덱스를 만들고 싶다면 private key인 컬럼은 NONCLUSTERED옵션을 주고 클러스터형 인덱스를 만들고 싶은 컬럼에는 CLUSTERED옵션을 주면 됩니다.



#### 인덱스 스캔의 종류 

------



##### FULL TABLE SCAN

위의 예시에서 만약 index가 설정되어 있지 않다면 Database는 title이 "DB인덱스"인 것을 찾기 위해서 Full table 한다고 합니다. 이 방법은 row의 값을 순차적으로 scan하며 비교합니다. 그런 만큼 속도도 늘릴 것이며 Disk를 읽기 위한 I/O 자원 사용이 많아질 것입니다. 총체적 난국이죠. 이를 해결하기 위해 인덱스를 만들고 인덱스 스캔이 필요합니다.



만약 인덱스가 걸려있어도 FULL TABLE SCAN을 하는 경우가 있습니다. 다음의 경우에 해당합니다.

1. SQL문에 조건이 존재하지 않는 경우 
   - 조건이 없다는 건 전체를 조회한다는 것입니다. 당연히 풀 테이블 스캔을 하게 됩니다.
2. SQL문의 주어진 조건에 사용 가능한 인덱스가 존재하지 않는 경우
   - 인덱스가 없는 경우인데요, 이경우도 당연히 풀 테이블 스캔을 하게 됩니다.
3. 옵티마이저의 취사 선택
   - 조건을 만족하는 데이터가 많은 경우, 결과를 추출하기 위해서 테이블의 대부분의 블록을 액세스 해야 한다고 옵티마이저가 판단한다면 조건에 사용 가능한 인덱스가 존재해도 전체 테이블 스캔 방식으로 읽을 수 있습니다.
4. 그 밖의 경우
   - 병렬처리 방식으로 처리하는 경우 또는 전체 테이블 스캔 방식의 힌트를 사용한 경우에 전체 테이블 스캔 방식으로 데이터를 읽을 수 있습니다.



##### INDEX SCAN

인덱스의 스캔 중에서 자주 사용되는 스캔은 유일 인덱스 스캔, 인덱스 번위 스캔, 인덱스 역순 범위 스캔이 있습니다. 내용은 다음과 같습니다.



1. 인덱스 유일 스캔(Index Unique Scan)
   - 인덱스 유일 스캔은 유일 인덱스를 사용하여 단 하나의 데이터를 추출하는 방식입니다. 유일 인덱스는 중복을 허락하지 않습니다. 만약 "="로 검색을 한다면 결과는 최대 1건이 됩니다. 
2. 인덱스 범위 스캔(Index Range Scan)
   - 인덱스 범위 스캔은 인덱스를 이용하여 한 건 이상의 데이터를 추출하는 방식입니다. 인덱스 유일 스캔이 아닌 모든 경우에 대해 이용하는 방식입니다. Leaf node를 오름차순으로 스캔하면서 값들을 찾던지, 내림차순으로 값들을 찾습니다.
   - 물론 Leaf Node까지 찾는 방법은 B-Tree 인덱스를 설명할 때 배운 내용입니다. 해당하는 범위안에 있는 Leaf Node를 내림차순, 오름차순을 하며 범위안에 값들을 모두 찾습니다. 이렇게 찾을 수 있는 이유는 Leaf Node가 양방향이기 때문입니다.

![image-20190130012516557](/assets/img/image-20190130012516557.png)

그림 참고 http://www.dbguide.net/db

스캔 방식은 이외에도 인덱스 전체 스캔, 인덱스 고속 전체 스캔, 인덱스 스킵 스캔등이 있습니다.



#### 옵티마이저의 취사 선택

아까 위에서 인덱스 스캔의 종류중 full table scan을 설명할 때 옵티마이저의 선택에 따라 인덱스가 있어도 전체 테이블 방식으로 읽을 수 있다고 했습니다. 이런 이유에 대해 더 자세히 알아보도록 하겠습니다.



데이터를 액세스하는 방법은 인덱스를 경유해서 읽는 인덱스 스캔 방식과 테이블 전체 데이터를 모두 읽으면서 데이터를 추출하는 전체 테이블 스캔방식 두개로 나눌 수 있습니다. 

여기서  인덱스 스캔방식은 한번의 I/O요청에 한 블록씩 데이터를 읽습니다. 그러나 전체 테이블 스캔은 데이터를 읽을 때 한 번의 I/O 요청으로 여러 블록을 한꺼번에 읽습니다. 만약 검색을 할 때 테이블의 많은 부분들을 읽게 된다면 인덱스 스캔방식은 I/O요청이 많아지면서 전체 테이블 스캔보다 비효율적인 데이터 액세스 방식이 될 수 있습니다. 이런 점들을 고려하여 옵티마이저는 인덱스 스캔과 전체 테이블 스캔 방식중 하나를 선택해서 데이터 액세스를 하게됩니다.



#### 참고자료

https://nesoy.github.io/articles/2017-07/DBIndex

https://jojoldu.tistory.com/243

https://jeong-pro.tistory.com/114

http://www.gurubee.net/lecture/2926

https://asfirstalways.tistory.com/333

http://www.dbguide.net/db.db?cmd=view&boardUid=148209&boardConfigUid=9&categoryUid=216&boardIdx=136&boardStep=1

https://mee2ro.tistory.com/2